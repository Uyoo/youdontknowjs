---
tags: You Dont Know JS
study: ch5.2 ~ part2 / ch1
---

# Week 4

### 5.2 연산자 우선순위

자바스크립트에서 &&, || 연산자는 단순히 true / false를 반환하는 게 아니라, 독특하게도 피연산자 중 하나를 선택하여 반환한다.

```javascript
var a = 42;
var b = "foo";

a && b; // "foo";
a || b; // 42
```

연산자가 2개, 3개일 경우 어떤 규칙으로 처리되는지 알아야한다.

```javascript
var a = 42;
var b = "foo";
var c = [1, 2, 3];

(a && b) || c; // "foo" : &&의 결과가 참이므로 바로 b를 반환한다.
a || (b && c); // 42 : a || b의 결과가 참이므로 바로 b를 반환한다.
```

이전에 봤던 예제.

```javascript
var a = 42,
  b;
b = (a++, a);

a; // 43
b; // 43

var a = 42,
  b;
(b = a++), a;

a; // 43
b; // 42
```

,연산자가 = 연산자보다 우선순위가 낮기 때문에 보여지는 결과이다. (연산자는 우선순위가 최하위다)

```javascript
if (str && (matches = str.match(/[aeiou]/g))) {
  // ...
}
```

&&가 =보다 우선순위가 높으므로 ()로 묶어줘야 한다.

- **&&가 || 보다 우선하여 처리된다.** &&, || 연산자는 **좌측 피연산자의 평가 결과만으로 전체 결과가 이미 결정될 경우 우측 피연산자의 평가를 건너뛴다.**
- 우선순위 순서: "&&" > "||" > "? :"

```javascript
a && b && c;
```

이 코드에서는 암시적인 그룹핑이 발생한다. 즉, a && b와 b && c 중 어느 한 편이 먼저 평가된다. &&는 좌측부터 결합하므로 a && b && c는 (a && b) && c와 같다. 또한 a && (b && c) 라도 같다. **동일한 값에 대하여 동일한 표현식은 항상 동일한 순서로 평가된다.**

> 만약 &&가 우측부터 하더라도 그룹핑이 그렇다는 것이지 그룹핑안에서 우측부터 처리되진 않는다.

"? :"는 우측 결합성 연산자다. 우측부터 결합하므로 미묘하게 차이가 있다.

```javascript
var a = true,
  b = false,
  c = true,
  d = true,
  e = false;

a ? b : c ? d : e; // false, 'a'와 'b'만 평가한다.
(a ? b : c) ? d : e; // false, 'a'와 'b', 'e'를 평가한다.
```

"="도 우측 결합성 연산자 중 하나이다.

```javascript
var a, b, c;
a = b = c = 42;
```

a = b = c = 42는 c = 42 -> b = ... -> a = ... 순서로 처리된다.

명시적으로 감싸줘야할까 규칙에 따라 코딩해야할까?
-> 개인적인 의견(성동) "읽기 쉬운 코드를 작성하자"

### 5.3 세미콜론 자동 삽입

기본적으로 자바스크립트 파서는 줄 단위로 파싱을 하다가 에러가 나면 ;을 넣어보고 타당한 것 같으면 ;를 삽입한다. (ASI, 자동 세미콜론 삽입)

쓸지 안쓸지는 주관적인 생각에 따라..

### 5.4 에러

- TDZ: ES6 임시 데드 존, 아직 초기화 하지 않아 변수를 참조할 수 없는 영역

```javascript
{
  a = 2;
  let a;

  type of a // undfeind
  typeof b; // ReferenceError! (TDZ)
  let a;
}
```

- 함수 인자

  - 아무런 인자를 넘기지 않았을 때 argument 배열에 원소가 없다. 이 때 default 인자 값은 적용된다.

- try ... finally

  - ```javascript
    function foo() {
      try {
        return 42; // 완료값을 42로 할당
      } finally {
        console.log("Hello");
      }

      console.log("실행안됨");
    }

    console.log(foo());

    // Hello
    // 42
    ```

  - finally 절에서 예와가 던져지면, 이전의 실행 결과는 모두 무시한다. 즉, try 에서 완료값이 있어도 완전히 사장된다.

  - ```javascript
    for (var i = 0; i < 10; i++) {
      try {
        continue;
      } finally {
        console.log(i);
      }
    }
    ```

  - 0~9가 출력
  - finally의 return은 try나 catch절의 return을 덮어쓴다.

- switch
  - case문은 엄격비교로 이루어진다( `case (a || b === 10): // false` )
  - 중간에 default 구문을 사용해도 되지만 꼭 break를 써줘야한다.

## Part 2. Ch1. 스코프란 무엇인가

특정 장소에 변수를 저장하고 나중에 그 변수를 찾는데 잘 정의된 규칙이 필요하다. 이런 규칙을 스코프라 한다.

### 1.1 컴파일러 이론

- 자바스크립트는 컴파일 언어이다.
- 토크나이징 / 렉싱 / 파싱 / 코드 생성의 과정을 거친다.
  - 토크나이징은 문자열을 의미있는 조각으로 만든다.
    - "var a = 2" -> var, a, =, 2, ;
  - 렉싱은 별개의 토큰인지, 다른 토큰의 일부인지를 파악한다.
  - 파싱에서 문법구조를 반영하여 트리 형태로 바꾼다.
  - 코드를 생성한다
- 자바스크립트는 코드가 실행되기 겨우 수백만 분의 일초전에 수행한다.

### 1.2 스코프 이해하기

- 엔진 : 컴파일 전 과정과 실행을 책임진다.
- 컴파일러 : 파싱과 코드 생성을 수행한다.
- 스코프 : 선언된 변수 목록을 작성하고 유지한다.
- ex) "var a = 2"
  - 컴파일러는 스코프에게 a가 있는지 묻는다
  - 있으면 무시하고, 없으면 스코프에게 선언하라고 한다.
  - a라는 변수가 스코프에게 있는지 물어본다.
  - 없으면 다른 스코프를 살핀다.
  - 2를 대입하기 위해 코드를 생성한다.
- 컴파일러체

  - LHS (대입할 대상)
    - 변수가 대입 연산자의 왼쪽에 있을 때 수행
  - RHS (대입한 값)
    - 대입 연산자의 오른쪽에 있을 때 수행
  - 예시

  ```javascript
  function foo(a) {
    // LHS : b = a
    // RHS : b = a
    var b = a;
    // RHS : return a + b
    return a + b;
  }
  // LHS : a = 2, c = foo(2)
  // RHS : c = foo(2)
  var c = foo(2);
  ```

- 중첩 스코프

  - 예시

  ```javascript
  function foo(a) {
    console.log(a + b);
  }
  var b = 2;
  foo(2); // 4
  ```

  - 엔진 : foo 스코프! b는 어딨는거야?
  - 스코프 : 여긴 없어
  - 엔진 : foo의 바깥 스코프! b라고 알아?
  - 스코프 : 여기있어~
  - RHS 검색이 실패하면 에러 발생(ReferenceError)

**스코프는 어디서 어떻게 변수를 찾는가를 결정하는 규칙의 집합**이다. 변수를 검색하는 이유는 변수에 값을 대입하거나(LHS) 변수의 값을 얻어오기 위해서이다(RHS).
