---
tags: You Dont Know JS
---

# Week 4

### 5.2 연산자 우선순위

- 표현식에 연산자가 여러 개 있을 경우 어떤 규칙으로 처리되는 지 알아야한다.
- 다수의 문을 연결하는 연산자로 ,를 사용할 때에는 이 연산자의 우선순위가 최하위라는 사실을 알고 있어야 한다.

```javascript
if (str && (matches = str.match(/[aeiou]/g))) {
  //
}
```

- 위 예제에서 할당문 양쪽을 ()로 감싸야 한다. &&가 = 보다 우선순위가 높으므로 ()로 묶어주지 않으면 표현식은 (str && matches) = ...로 처리된다.

```javascript
var a = 42
var b = "foo"
var c = false

var d = (a && b) || c ? (c || b ? a : c && b) : a
```

- 위 예제에서 d의 값은 42이다.
- && 연산자는 || 보다 우선순위가 높다.
- 모든 프로그래밍 언어에는 연산자 우선순위가 있다.

#### 5.2.1 단락 평가

- &&, || 연산자는 좌측 피연산자의 평과 결과만으로 전체 결과가 이미 결정될 경우 우측 피연산자의 평가를 건너뛴다.
- 예를 들어 a && b에서 a가 falsy면 b는 보지도 않고 a를 리턴한다. 마찬가지로 a || b에서 a가 true면 b를 보지도 않고 a를 리턴한다.
- 단락평가는 일종의 가드로써 자주 쓰인다.

#### 5.2.2 끈끈한 우정

- &&가 ||보다, ||가 ? :보다 우선순위가 더 높다.

#### 5.2.3 결합성

- 일반적으로 연산자는 좌측부터 그룹핑이 일어나는지 우측부터 그루핑이 일어나는지에 따라 좌측 결합성 또는 우측 결합성을 가진다.
- &&는 좌측부터 결합한다.
- ? : 연산자는 우측 결합성 연산자이다. 우측부터 그룹핑을 한다.
- = 도 우측 결합성 연산자 중 하나다.

#### 5.2.4 분명히 하자

- 연산자 우선순위/결합성을 적절히 활용하여 짧꼬 깔끔한 코드를 작성하되 혼동을 줄이고 분명히 밝혀야 할 부분은 ()로 감싸주자

### 5.3 세미콜론 자동 삽입

- ASI(Automatic Semicolon Insertion)은 자바스크립트 프로그램의 세미콜론이 누락된 곳에 엔진이 자동으로 ;을 삽입하는 것을 말한다.
- ASI는 새 줄에만 적용되며 어떠한 경우에도 줄 중간에 삽입되는 일은 없다.

#### 5.3.1 에러 정정

- 저자의 결론은 필요하다고 생각하는 곳이라면 어디든지 세미콜론을 사용하고, ASI가 어떻게든 뭔가 해줄 거라는 가정은 최소화 하자는 것이다.

### 5.4

- 자바스크립트는 일부 에러는 컴파일 시점에 발생하도록 문법적으로 정의되어 있다. 구문 에러나, 구문 상 오류는 아니지만 허용되지 않는 것들도 정의되어 있다. 이런 에러는 try catch로 잡을 수 없으며, 그냥 프로그램 파싱/컴파일이 실패한다.
- 올바르지 않은 정규 표현식은 조기 에러를 던진다.
- ES5 엄격 모드는 조기 에러가 더 많다. (함수 인자명 중복, 객체 리터럴의 동일한 프로퍼티 명 중복 등)

#### 5.4.1 너무 이른 변수 사용

- ES6는 TDZ(임시 데드 존)이라는 새로운 개념을 도입했다. TDZ는 아직 초기화를 하지 않아 변수를 참조할 수 없는 코드 영역이다.

```javascript
{
  a = 2 // ReferenceError!
  let a
}

{
  typeof a // undefined
  typeof b // ReferenceError
  let b
}
```

### 5.5 함수 인자

- TDZ 관련 에러는 ES6 디폴트 인자 값에서도 찾아볼 수 있다.
- ES6 디폴트 인자 값은 함수에 인자를 넘기지 않거나 undefined를 전달했을 때 적용된다.

```javascript
var b = 3
function foo(a = 42, b = a + b + 5) {
  //
}
```

- 위 예에서 좌변 b는 아직 TDZ에 남아있는 b를 참조하려고 하기 때문에 에러를 던진다.
- 함수 내에서 유사 배열인 arguments는 함수 호출 시 인자를 가지고 요소로 가지고 있는 유사 배열이다. 인자가 없으면 요소가 존재하지 않는다.
- arguments 배열은 이제 비권장 요소이다. 대신 나머지 인자(...)를 사용하는 것을 권장하고 있다.

### 5.6 try...finally

- finally 절의 코드는 반드시 실행되고 다른 코드로 넘어가기 전에 try 이후부터 (catch가 있으면 catch 다음부터) 항상 실행된다.

```javascript
function foo() {
  try {
    return 42
  } finally {
    console.log("Hello")
  }
  console.log("실행될 리 없지")
}
console.log(foo())
// Hello;
// 42;
```

- 위 예제에서 foo함수의 완료 값은 42로세팅되고, try 절의 실행이 종료되면서 곧바로 finally 절로 넘어간다. throw가 있어도 비슷하다.
- finally 절에서 예외가 던져지면, 이전의 실행 결과는 모두 무시한다.
- continue나 break 같은 비선형 제어문 역시 return과 throw와 비슷하게 동작한다.
- finally 절에서 return이 있다면 그 이전에 실행된 try나 catch절의 return을 덮어쓰는 특출한 능력이있다.
- 레이블 break와 finally를 조합해서 사용하는 골치 아픈 코드는 사용하지 말자.

### 5.7 switch

- switch에는 기벽이 있다.

1. switch 표현식과 case 표현식 간의 매치 과정은 === 알고리즘과 똑같다. 하지만 == 알고리즘을 이용하고 싶다면 아래와 같이 하면 된다.

```javascript
var a = "42"

switch (true) {
  case a == 10:
    console.log('10'또는 10);
    break;
}
```

2. default 절은 선택 사항이며 꼭 끝 부분에 쓸 필요는 없다. 하지만 default에서도 break를 안 써주면 그 이후로 코드가 계속 실행된다.

- switch 문을 이용할 때는 break문을 꼭 써주자.

## Ch1 스코프란 무엇인가

- 특정 장소에 변수를 저장하고 나중에 그 변수를 찾는 데는 잘 정의된 규칙이 필요하다. 이런 규칙을 스코프라고 한다.

### 1.1 컴파일러 이론

- 자바스크립트는 사실 컴파일러 언어다.
- 전통적인 컴파일러 언어의 처리 과정에서는 프로그램을 이루는 소스 코드가 실행되기 전에 보통 3단계를 거치는데, 이를 '컴파일레이션' 이라고 한다.

#### 토크나이징/렉싱

- 문자열을 나누어 '토큰'이라 불리는 의미 있는 조각으로 만드는 과정이다.

```javascript
var a = 2;
// 위는 아래의 토큰으로 나눌 수 있다.
var,
a
=
2
;
```

- 토크나이징과 렉싱은 미묘한 차이가 있는데, 토큰을 인식할 때 무상태 방식으로 하는지 상태 유지 방식으로 하는지에 따라 구분한다. 토크나이저가 상태 유지 파싱 규칙을 적용해 a가 별개의 토큰인지 다른 토큰의 일부인지를 파악한다면 렉싱이다.

#### 파싱

- 토큰 배열을 프로그램의 문법 구조를 반영하여 중첩 원소를 갖는 트리 형태로 바꾸는 과정이다. 파싱의 결과로 만들어진 트리를 AST (Abstract Syntax Tree)- 추상 구문 트리라고 부른다.
- var a = 2;의 경우에는 먼저 변수 선언이라 부르는 최상위 노드에서 시작하고, 최상위 노드는 'a'의 값을 가지는 확인자와 대입 수식이라 부르는 자식 노드를 가진다. 대입 수식 노드는 '2' 라는 값을 가지는 숫자 리터럴을 자식 노드로 가진다.

#### 코드 생성

- AST를 컴퓨터에서 실행 코드로 바꾸는 과정이다.
- 자바스크립트 엔진은 파싱과 코드 생성 과정에서 불필요한 요소를 삭제하는 과정을 거쳐 실행 시 성능을 최적화한다.
- 자바스크립트는 컴파일레이션을 미리 수행하지 않아서 최적화할 시간이 많지 않다는 것이다.
- 결론은 어떤 자바스크립트 조각이라도 실행되려면 먼저 컴파일되어야 한다는 것이다.

### 1.2 스코프 이해하기

- 스코프를 대화 형식으로 풀어서 설명한다.

#### 1.2.1 출연진

- 엔진: 컴파일레이션의 시작부터 끝까지 전 과정과 자바스크립트 프로그램 실행을 책임진다.
- 컴파일러: 엔진의 친구로, 파싱과 코드 생성의 모든 잡일을 도맡아 한다.
- 스코프: 엔진의 또 다른 친구로, 선언된 모든 확인자 검색 목록을 작성하고 유지한다. 또한, 엄격한 규칙을 강제하여 현재 실행 코드에서 확인자의 적용 방식을 정한다.

#### 1.2.2 앞과 뒤

- 프로그램에서 컴파일러가 할 첫 번째 일은 렉싱을 통해 구문을 토큰으로 쪼개는 것이다. 그 후 토큰을 파싱해 트리 구조로 만든다.
- 컴파일러가 var a를 만나면 스코프에게 변수 a가 특정한 스코프 컬렉션 안에 있는지 묻는다. 변수 a가 이미 있다면 컴파일러는 선언을 무시하고 지나가고, 그렇지 않으면 컴파일러는 새로운 변수 a를 스코프 컬렉션 내에 선언하라고 요청한다.
- 그 후 컴파일러는 'a = 2' 대입문을 처리하기 위해 나중에 엔진이 실행할 수 있는 코드를 생성한다. 엔진이 실행하는 코드는 먼저 스코프에게 a라 부르는 변수가 현재 스코프 컬렉션 내에서 접근할 수 있는지 확인한다. 가능하다면 엔진은 변수 a를 사용하고, 아니라면 엔진은 다른 곳을 살핀다.
- 요약하자면 첫째로 컴파일러가 변수를 선언하고, 둘째로 엔진이 스코프에서 변수를 찾고 변수가 있다면 값을 대입한다.

#### 1.2.3 컴파일러체

- 스코프에서 변수를 검색할 때 LHS 또는 RHS 검색을 수행한다.
- RHS 검색은 단순히 특정 변수의 값을 찾는 것과 다르지 않고, LHS 검색은 값을 넣어야 하므로 변수 컨테이너 자체를 찾는다.

```javascript
console.log(a) // RHS 참조. 구문에서 a에 아무것도 대입하지 않는다. 단순히 a의 값을 가져와 함수의 인자로 넣어준다.

a = 2 // LHS 참조. 현재 a 값을 신경 쓰지 않고 대입 연산을 수행할 대상 변수를 찾기 때문이다.

function foo(a) {
  console.log(a) // 2
}

foo(2)
```

- 함수 foo를 호출하는데 RHS 참조를 사용한다. (foo 값을 가져와야 함) 코드 속에 내재된 a = 2 라는 LHS 검색이 수행된다. 변수 a에 대한 RHS 참조도 수행되고, 그 결과 값은 console.log 함수에 넘겨진다. console.log도 RHS 참조가 필요하다. console 객체를 RHS 검색을 하기 때문이다. log 메서드 내부에 인자가 있을 것이고 arg1 = 2 로 LHS 검색으로 인자를 찾아 2를 대입한다.

#### 1.2.4 엔진과 스코프의 대화

```javascript
function foo(a) {
  console.log(a) // 2
}

foo(2)
```

1. 엔진: foo에 대한 RHS 참조가 필요하다.
2. 스코프: 컴파일러가 좀 전에 선언했다. (foo에 대한 정보 넘겨줌)
3. 엔진: 이제 foo를 실행하겠다.
4. 엔진: a에 대한 LHS 참조도 구해야 한다.
5. 스코프: 컴파일러가 a를 foo의 인자로 선언했다.
6. 엔진: 이제 2를 a에 대입한다.
7. 엔진: console에 대한 RHS 검색이 필요하다.
8. 스코프: 내장되어 있는 console 객체에 대한 정보를 넘김
9. 엔진: console 객체 내부의 log함수를 실행하려고 함
10. 엔진: a의 RHS 참조가 필요하다.
11. 엔진: 스코프에게서 받은 a의 값을 log함수에 인자로 넘긴다.

### 1.3 중첩 스코프

- 하나의 블록이나 함수는 다른 블록이나 함수 안에 중첩될 수 있으므로 스코프도 다른 스코프 안에 중첩될 수 있다. 대상 변수를 현재 스코프에서 발견하지 못하면 엔진은 다음 바깥의 스코프로 넘어가서 찾거나 글로벌 스코프라 부르는 가장 바깥 스코프에 도달할 때까지 계속 한다.

```javascript
function foo(a) {
  console.log(a + b)
}
var b = 2
foo(2) // 4
```

- b에 대한 RHS 참조는 함수 foo 안에서 처리할 수 없고, 함수를 포함하는 스코프에서 처리한다.
- 중첩 스코프 탐사할 때 사용하는 규칙

1. 엔진은 현재 스코프에서 변수를 찾기 시작하고, 찾지 못하면 한 단계씩 올라간다.
2. 최상위 글로벌 스코프에 도달하면 변수를 찾았든, 못 찾았든 검색을 멈춘다.

### 1.4 오류

- LHS, RHS 검색 방식은 변수가 아직 선언되지 않았을 때 서로 다르게 동작하기 때문에 반드시 구분해야 한다.

```javascript
function foo(a) {
  console.log(a + b)
}
var b = 2
foo(2) // 4
```

- b에 대한 첫 RHS 검색이 실패하면 다시는 b를 찾을 수 없다. RHS 검색이 중첩 스코프 안 어디에서도 변수를 찾지 못하면 엔진이 'ReferenceError'를 발생시킨다.
- 반면 엔진이 LHS 검색을 수행하여 변수를 찾지 못하고 최상위 층에 도착할 때 프로그램이 'strict mode'로 동작하고 있는 것이 아니라면, 글로벌 스코프는 엔진이 검색하는 이름을 가진 새로운 변수를 생성해서 엔진에게 넘겨준다. (결국 이렇게 되면 예상하지 못한 글로벌 변수를 생성하게 되는 것이다.)
- 'strict mode'로 동작할 경우는 RHS 검색과 마찬가지로 에러를 발생시킨다.
