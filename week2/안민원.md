---
tags: You Dont Know JS
---

# Week 2

## Ch3 네이티브

- 네이티브는 특정 환경(브라우저등의 클라이언트 프로그램)에 종속되지 않은 ECMAScript 명세의 내장 함수다.
- 가장 많이 쓰는 네이티브들은 다음과 같다.

```javascript
String();
Number();
Boolean();
Array();
Object();
Function();
RegExp();
Date();
Error();
Symbol();
```

```javascript
// new String을 예를 들자

var s = new String("Hello World");
typeof s; // "object" 이며 "string"이 아니다.
```

- new String()은 내부 인자를 감싸는 문재열 래퍼를 생성하며 원시값 "Hello World"는 아니다.
- 위의 예를 보면 s는 String 클래스의 인스턴스고, 아래와 같이 나온다.

```javascript
String {"Hello World"}
{
  0: "H"
  1: "e"
  2: "l"
  3: "l"
  4: "o"
  5: " "
  6: "W"
  7: "o"
  8: "r"
  9: "l"
  10: "d"
  length: 11
  __proto__: String,
  [[PrimitiveValue]]: "Hello World"
}
```

### 3.1 내부 [[Class]]

- 대부분 내부 [[Class]]는 해당 값과 관련된 내장 네이티브 생성자를 가리킨다 (단 null, undefined는 제외)
- Null() 이나 Undefined() 같은 네이티브 생성자는 없다.
- 그 밖의 원시값 (String, Number, Boolean)은 자동적으로 박싱되어 내부 [[Class]] 값이 String, Number, Boolean으로 표시되어 보인다.

### 3.2 래퍼 박싱하기

- 원시 값엔 프로퍼티나 메서드가 없으므로, .length나 toString()으로 접근하려면 원시 값을 객체 래퍼로 감싸줘야 한다.
- 자바스크립트는 원시 값을 알아서 박싱한다.
- 하지만 이런 이유때문에 원시값을 모두 네이티브 생성자로 생성할 필요가 없다. 브라우저는 이런 경우를 스스로 최적화하기 때문이다. 오히려 개발자가 나섰다가 더 느려진다.
- Boolean 값을 객체 래퍼로 박싱하여 사용하는 것은 객체가 truthy 값이기 때문에 문제가 발생한다. 사용하지 말자
- 수동으로 원시값을 객체 래퍼로 박싱하는 것을 Object 함수를 이용하자

### 3.3 언박싱

- 객체 래퍼의 원시값은 valueOf() 메서드로 추출한다.
- 암시적인 언박싱은 내용은 4장에서 확인하자

### 3.4 네이티브, 나는 생성자다

- 확실히 필요해서 쓰는 게 아니라면 생성자는 가급적 쓰지 않는 편이 좋다.

#### 3.4.1 Array()

```javascript
var a = new Array(1, 2, 3);
a; // [1,2,3]

var b = [1, 2, 3];
b; // [1,2,3]
```

- 결과적으로 같다.

- Array 생성자는 인자로 숫자를 하나만 받으면 그 숫자를 해당 배열의 크기로 미리 정하는 기능이 있다.
- 실제로 슬롯에 값은 없지만 length로 보면 값이 있어보이는 배열이 완성된다.

```javascript
var a = new Array(3);

a.length; // 3
```

- 위 코드를 크롬에서 확인 결과 [empty x 3] 이런식으로 나온다. 물론 배열 안에 요소는 없다.
- 파폭에서 확인한 결과 [undefined, undefined, undefined] 라고 나온다. 물론 실제 값이 undefiend가 들어있는게 아니다.
- 책에선 장황하게 설명했지만 절대로 무슨 일이 있어도 이런 멍청한 방식으로 빈 슬롯 배열을 애써 만들어서 멋 부리지 말라고 하고 있다.

#### 3.4.2 Object(), Function(), and RegExp()

- 이 세개의 생성자도 선택사항이다. (의도가 없다면 굳이 사용할 필요는 없다.)
- new Object() 같은 폼은 굳이 한 번에 하나씩 일일이 프로퍼티를 지정지 않는 이상 쓸 일이 없다.
- Function 생성자는 함수의 인자나 내용을 동적으로 정의해야 하는 드문 경우에 한해 유용하다고 하는데, 이런 경우라면 로직을 다시 생각해 보는것이 맞는 것 같다.
- 정규 표현식은 리터럴 형식이 쉽고 성능상의 이점이 있다고 한다. 하지만 RegExp()는 정규식 패턴을 동적으로 정의할 경우 의미가 있다고 한다.

```javascript
const regexpPeopleName = name => {
  return new RegExp(`${name}`, "ig");
};

const matches = someText.match(regexpPeopleName(name));
```

#### 3.4.3 Date() and Error()

- 생성자 Date()와 Error()는 리터럴 형식이 없으므로 유용하다.
- date 객체값은 new Date()로 생성한다. 인자로는 날짜/시각을 받는다. (인자가 없으면 현재 날짜/시각으로 대체)
- date 유닉스 타임스탬프 값을 얻으려면 Date.now()를 쓰는게 쉽다.
- Error 생성자는 new가 있든 없든 결과는 같다.
- 현재의 실행 스택 콘텍스트를 포착하여 객체에 담는 것이다. 보통 throw 연산자와 함께 사용한다.
- 사람이 읽기 편한 메시지를 보려면 error 객체의 toString()을 호출하는 것이 좋다.

#### 3.4.4 Symbol()

- ES6에서 처음 나온 원시 값 타입. 충돌 염려 없이 객체 프로퍼티로 사용 가능한, 특별한 '유일 값' 이다. (절대적 유일함은 아님)
- 주로 ES6의 특수한 내장 로직을 위해 고안 되었지만 심벌 정의는 얼마든지 가능하다
- 심벌을 직접 정의하려면 Symbol()을 사용한다. 앞에 new를 붙이면 안되는 유일한 생성자다.

#### 3.4.5 네이티브 프로토타입

- 내장 네이티브 생성자는 각자의 .prototype 객체를 가진다.
- prototype 객체에는 해당 객체의 하위 타입별로 고유한 로직이 담겨 있다.
- 예를 들면 모든 String 객체는 String.prototype 객체에 정의된 메서드에 접근할 수 있다.
- 문자열 값을 변경하는 메서드는 없다. 수정이 일어나면 늘 기존값에서 새로운 값을 생성한다.
- 프로토타입 위임 덕분에 모든 문자열이 메서드를 공유한다.
- 네이티브 프로토타입 중 Function과 RegExp, Array는 조금 특이하다
- 네이티브 프로토타입을 변경할 수도 있지만 절대 하지 말자.

## Ch4 강제변환

### 4.1 값 변환

- 어떤 값을 다른 타입의 값으로 바꾸는 과정이 명시적이면 '타입 캐스팅', 암시적이면 '강제변환' 이라고 한다
- 강제변환을 하면 문자열, 숫자, 불리언 중 하나가 된다. 박싱은 강제변환이 아니다.
- 명시적 강제변환은 코드만 봐도 의도적으로 타입변환을 일으키는 것이 명백하고, 암시적 강제변환은 다른 작업 도중 발생하는 부수 효과이다.

### 4.2 추상 연산

#### 4.2.1 ToString

- 내장 원시 값은 본연의 문자열화 방법이 정해져 있다. 너무 크거나 작은 숫자값은 지수 형태로 바뀐다.
- 일반 객체는 특별히 지정하지 않으면 기본적으로 toString() 메서드가 내부 [[Class]]를 반환한다 ([object object])
- 배열은 모든 원소 값이 콤마(,)로 분리된 형태로 이어진다.

##### JSON 문자열화

- 강제변환과 똑같지는 않지만, ToString 규칙과 관련이 있다.
- JSON 안전 값은 모둔 JSON.stringify()로 문자열화 할 수 있다.
- JSON 안전 값이 아닌 것들은 undefined, 함수, 심벌, 환형 참조 객체이다. 이들은 표준 JSON 객체 형식을 벗어난 값이다.
- JSON.stringify()는 인자가 안전 값이 아닌 것들은 자동으로 누락시키며 만약 배열에 포함되어 있으면 null로 바꾼다. 객체 프로퍼티에 있다면 지워버린다.
- toJSON()의 역할은 '문자열화하기 적당한 JSON 안전 값으로 바꾸는 것'이지 JSON 문자열로 바꾸는 것이 아니다.
- JSON.stringify()의 두번째 인자로 배열 또는 함수가 들어가는 데, 객체를 필터링 하는 방법으로 쓰인다.
- JSON.stringify()의 세번째 인자는 스페이스라고 하며, 들여쓰기를 할 수 있다. 빈 공간의 갯수를 숫자로 지정하거나 문자열을 지정하여 들여쓰기에 사용한다.

#### 4.2.2 ToNumber

- 숫자 아닌 값 -> 수식 연산이 가능한 숫자 변환 로직은 ES5 9.3 ToNumber 추상 연산에 나와있다. (https://www.ecma-international.org/ecma-262/5.1/)
- 예를 들어 true는 1, false는 0, undefined는 NaN, null은 0으로 바뀐다.
- 변환이 실패하면 에러를 내지 않고 NaN을 반환한다.
- 객체 변환의 경우 일단 동등한 원시 값으로 변환 후 그 결괏값을 ToNumber 규칙에 의해 강제변환한다.
- 객체의 경우 일단 valueOf()를 쓸 수 있고 반환 값이 원시 값이면 그대로 강제변환한다.
- 그렇지 않을 경우 toString() 메서드를 이용하여 강제변환한다.
- 어찌해도 원시 값으로 바꿀 수 없느 경우는 TypeError 오류를 던진다.

#### 4.2.3 ToBoolean

##### Falsy 값

- 자바스크립트의 모든 값은 불리언으로 강제변환하면 falsy 값이 되거나 truthy 값이 되거나 둘 중 하나다.
- 명세가 정의한 falsy 값은 다음과 같다

```javascript
undefined;
null;
false + 0, -0, NaN;
("");
```

- 이 목록에 있으면 falsy 값이며 불리언으로 강제변환 시 false가 된다.
- 위 목록에 없는 나머지는 truthy 값이다.

##### truthy 값

- falsy 목록에 없으면 무조건 truthy 값이다.

```javascript

'false'
'0'
"''"
[]
{}
function() {}
```

- 위 내용은 모두 truthy 값이다.
- 그렇기 때문에 얼마 안되는 falsy 값만 알고 있으면 된다.

### 4.3 명시적 강제변환

- 분명하고 확실한 타입변환이다.

#### 4.3.1 명시적 강제변환: 문자열 <-> 숫자

- String()과 Number() 함수를 이용한다. 앞에 new 키워드는 붙지 않는다.

```javascript
var a = 42;
var b = String(a); // "42"

var c = "3.14";
var d = Number(c); // 3.14
```

- 아래 예 처럼 단항 연산자 +를 사용해서 피연산자 c를 숫자로 명시적 강제변환 할 수 있다.

```javascript
var c = "3.14";
var d = +c; // 3.14
```

- 지그재그 과제 전형에서 이렇게 한 번 쓴 적이 있는데 명시적으로 변환하는게 좋겠다는 피드백을 받았다.
- 개발자의 경험과 시야에 따라 다르다고 한다.
- 가급적 +/- 단한 연산자를 다른 연산자와 인접하여 사용하지 말자. 혼동을 줄이는 게 좋다.

##### 날짜 -> 숫자

- 단항 연산자 +는 'Date 객체 -> 숫자' 강제변환 용도로도 쓰인다. 날짜 시각값을 유닉스 타임스탬프 표현형으로 나타낸다.
- 강제변환을 하지 않고 Date 객체로부터 타임스탬프를 얻는 방법은 new Date().getTime()이다.
- 현재 타임 스탬프는 Date.now()로 얻을 수 있다.
- 날짜 타입에 관한 한 강제변환은 권하고 싶지 않다고 한다.

##### 이상한 나라의 틸드(~)

- 비트 연산을 하면 피연산자는 32비트 값으로 강제로 맞춰진다. 이 역할은 ToInt32가 한다.
- ToInt32는 ToNumber 강제변환을 한다.
- ~ 연산자는 먼저 32비트 숫자로 강제변환 후 NOT 연산을 한다. (각 비트를 거꾸로 뒤집음)
- ~ 연산자가 쓸모 있는 경우는 indexOf() 같은 함수에 >= 0 이나 !== -1 과 같은 코드를 쓰지 않을 수 있기 때문이다.

```javascript
var a = "Hello World";

~a.indexOf("lo"); // -4. 3의 2의 보수인 -4를 구한다.

if (~a.indexOf("lo")) {
  // 어쩌구
}
```

##### 비트 잘라내기

- ~~는 32비트 값에 한하여 Math.floor() 와 같은 결과를 내지만 음수일 경우에는 다르다.
- **여러분의 코드를 읽을 주변 동료 개발자가 연산자의 작동 원리를 적절히 이해하고 있다는 전제하에!!!** 틸드를 잘 활용하기를 바란다.

#### 4.3.2 명시적 강제변환: 숫자 형태의 문자열 파싱

- 문자열로부터 숫자 값의 파싱은 비숫자형 문자를 허용한다. 좌 -> 우 방향으로 파싱하다가 숫자 같지 않은 문자를 만나면 즉시 멈춘다.
- 파싱은 강제변환이 아니다. 목적이 다르다.
- parseInt()는 문자열에 쓰는 함수이다. **절대로 parseInt()에 비문자열 값을 넘기지 말자**
- ES5 이후에는 두번째 인자가 없어도 알아서 10진수로 처리를 한다.
- **이상하게 사용해서 말도 안 되는 결과가 나왔다고 자바스크립트를 탓하지 말자.**

#### 4.3.3 명시적 강제변환: \* -> 불리언

- Boolean() 함수는 명시적인 강제 변환 방법이다.
- ! 단항 연산자도 값을 불리언으로 명시적으로 강제 변환한다.
- 명시적인 강제변환을 할 땐 !! 이중부정 연산자를 사용한다.
- if() 문 등읠 불리언 콘텍스트에서도 암시적인 강제 변환이 일어난다.
- 삼항 연산자에서도 표현식의 평과 결과에 따라서 명시적으로 암시적이라고 할 수 있는 변환이 일어난다. 무조건 쓰지 말자고 하는 데 굉장히 유용하고 많이 쓰이는 코드 중 하나이다.

