---
tags: You Dont Know JS
---

# Week 3

## Ch 4 강제 변환

### 4.4 암시적 변환

부수 효과가 명확하지 않게 **숨겨진 형태** 로 일어나는 타입변환이다. 암시적 강제변환의 목적은 장황함, 보일러 플레이트, 불필요한 상세 구현을 줄이는 것이다.

> 저자 생각 : 암시적 변환을 남용/오용하면 안전하지 않다. 그렇다고 해서 전부 다 폐기해야 할까? '나쁜 단면'만 보고 다 나쁘다고 단정하지 말자. 객관적으로 암시적 강제 변환을 수용하길 바란다.

#### 암시적 강제변환: 문자열 <-> 숫자

##### 숫자 -> 문자열

 **+ 알고리즘은 한쪽 피연산자가 문자열이거나 다음 과정을 통해 문자열 표현형으로 나타낼 수 있으면 문자열 붙이기를 한다.**  그 밖에는 언제나 숫자 덧셈을 한다.

```javascript
var a = 42;
var b = a + "";

b; // "42"

b = "" + a // +는 가환적이므로 결과가 같다. "42"

// 가환적인 연산 : 실수에서는 덧셈과 곱셈 연산이 가환적이다.
```

암시적 강제변환 시 연산 순서

1. a 값을 valueOf 메서드에 전달하여 호출 (숫자 42)
2. toString() 호출 (문자열 "42")

```javascript
var a = {
  valueOf: function() { return 42; }
  toString: function() { return 4; }
}

a + ""; // 42;

String(a); // "4" (toString()를 직접 호출)
```

valueOf, toString을 직접 구현한 객체가 있다면 강제변환 과정에서 결과값이 달라질 수 있으니 조심해야 한다.

##### 문자열 -> 숫자

**-, *, / 연산자는 숫자 연산만 하므로 숫자로 강제변환한다.**

```javascript
var a = "3.14";
var b = a - 0;

b; // 3.14

var a = [3]; 
var b = [1];

// 문자열로 강제변환한 뒤 숫자로 강제변환한다.
a.toString() // "3"
b.toString() // "3"
a - b; // 2
```

#### 암시적 강제변환: 불리언 <-> 숫자

위 사항과 비슷하게 숫자나 불리언을 암시적 강제변환하여 사용할 수 있다.

```javascript
+true // 1
+false // 0

!!1 // true
!!0 // false
```

#### 암시적 강제변환: * -> 불리언

불리언으로의 (암시적인) 강제변환이 일어나는 표현식

- if ()문의 조건 표현식
- for ( ; ; ) 에서 두번째 조건 표현식
- while () 및 do...while () 루프의 조건 표현식
- ? : 삼항 연산 시 첫번째 조건 표현식
- || (논리 OR) 및 && (논리 AND)의 좌측 피연산자

### 4.4.5 && 연산자와 || 연산자

&& 또는 || 연산자의 결과값이 반드시 불리언 타입이어야 하는 것은 아니며 항상 두 피연산자 표현식 중 어느 한쪽 값으로 귀결된다.

따라서 || , && 표현식의 결과값은 언제나 **피연산자의 값 중 하나이며 평가 결과가 아니다.**

> 저자는 이들을 말할 때 논리 연산자가 아니라 '피연산자 선택 연산자'가 더 적절하다고 말한다.

```javascript
a || b; // a ? a : b
a && b; // a ? b : a

function foo(a, b) {
  a = a || "hello";
  b = b || "world";
  
  console.log(a + " " + b);
}

foo(); // "hello world"
foo("오 마이", "갓!"); // "오 마이 갓!"
```

### 4.4.6 심벌의 강제변환

```javascript
var s1 = Symbol("좋아");
String(s1); // "Symbol(좋아)"

var s2 = Symbol("구려");
s2 + ""; // TypeError
```

심벌 값은 절대 숫자로 변환되지 않지만 불리언 값으로는 명시적/암시적 모두 강제변환이 가능하다. 하지만 원래 만들어진 의도대로만 사용한다면 강제변환할 필요는 거의 없을 것이다.

## 4.5 느슨한/엄격한 동등 비교

많은 이들이 "==는 값의 동등함을, === 는 값과 타입 모두의 동등함을 비교한다" 라고 하지만 불행하게도 모두 틀렸다. **동등함의 비교 시 == 는 강제변환을 허용하지만, ===는 강제변환을 허용하지 않는다.**

전자에 의하면 "==="는 타입까지 검사하므로 "==에" 비해 할 일이 많다. 후자에 따르면 오히려 타입이 다를 경우 강제변환을 해야 하므로 ==가 할일이 더 많다. 타입이 같다면 "=="와 "==="의 알고리즘은 동일하다.

타입이 다른 두 값을 느슨한 동등 비교(==) 시, 한쪽 또는 양쪽 피연산자에서 암시적 강제변환이 일어난다. 결과적으로 두 값의 타입을 일치시켜 간단히 값만 보고 비교하기 위함이다.

다만, 다음 예외는 주의해야 한다.

- NaN은 그 자신과도 결코 동등하지 않다.
- +0과 -0은 동등하지 않다.

객체의 느슨한 동등비교에 대해서는 두 객체가 정확히 똑같은 값에 대한 레퍼런스일 경우에만 동등하다고 기술되어 있다. 이 때 강제변환은 이루어지지 않는다. (객체의 동등비교는 ==와 ===의 로직이 똑같다.)

**== 의 비교 알고리즘이 각 타입 조합별로 어떻게 작동하는가가 중요하다.**

```javascript
// 비교하기: 문자열 -> 숫자
var a = 42;
var b = "42";

a === b; // false : 강제변환이 허용되지 않는다.
a == b; // true : b를 숫자로 변환(강제변환이 허용)하여 비교한다.
```

```javascript
// 비교하기: * -> 불리언
var a = 42;
var b = true;

a == b; // false : b -> 1로 강제변환된다. 결국 1 === "42"가 된다.
```

```javascript
// 비교하기: null -> undefined
var a = null;
var b;

a == b; // true
a == null; // true
b == null; // true

// 즉 null과 undefined 자신들끼리 비교 결과가 true이므로, 이외의 값들과 비교했을 때 결과값이 true일 가능성은 없다.
```

```javascript
// 비교하기: 객체 -> 비객체
var a = 42;
var b = [42]; 

a == b; // true : b의 ToPrimitive 의 결과 "42"가 되고 숫자 42로 다시 강제변환된다. 따라서 42 == 42로 동등하다.
```

### 4.5.3 희귀 사례

prototype의 임의 변경은 생각조차 하지 말자.

#### 근본부터 따져보자

예상을 벗어난 정도를 기준으로 하면 강제변환이 심각한 문제가 될 경우는 7가지이다.

```javascript
"0" == false; // true
false == 0; // true
false == ""; // true
false == []; // true
"" == 0; // true
"" == []; // true
0 == []; // true
```

#### 암시적 강제변환의 안전한 사용법

- 피연산자 중 하나가 true/false/일 가능성이 있으면 '절대로' == 연산자를 쓰지 말자.
- 피연산자 중 하나가 [], " ", 0이 될 가능성이 있으면 가급적 == 연산자는 쓰지 말자.

== 대신 ===을 사용하여 의도하지 않은 강제변환을 차단하는 게 훨씬 좋다.

## 4.6 추상 관계 비교

'추상적 관계 비교' 알고리즘은 비교 시 피연산자 모두 문자열일 때와 그 외의 경우, 두가지로 나뉜다.

```javascript
// 모두 문자열이 아닐 경우
var a = [42]; // a -> 42
var b = ["43"]; // a -> "43"

// 모두 문자열일 경우 (알파벳 순으로 비교)
a < b; // true: 42 < 43
b < a; // false: 43 < 42

a = ["42"]; // a -> "42"
b = ["043"]; // b -> "043"
a < b; // false: "42" < "043"
```

객체의 추상관계 비교 시에는

```javascript
var a = { b: 42 };
var b = { b: 43 };

a < b; // false
a == b; // false : 값 자체도 다른 별개의 객체다. 
a > b; // false 

a <= b; // true : b < a의 결과를 부정하도록 명세되어 있다.
a >= b; // true : b <= a 로 변환한 후 추론을 시작한다.
```

### 4.7 정리하기

**암시적 강제변환은 변환 과정이 구체적으로 어떻게 일어나는지 명확하게 알고 사용해야한다.**

## Ch 5. 문법

### 5.1 문(Statement) 과 표현식(Expression)

```javascript
var a = 3 * 6; // "3 * 6": 표현식, "var a = 3 * 6": 선언문
var b = a; // "b = a": 표현식, "var b = a": 선언문
b; // 표현식 문 (표현식의 전부이며 완전한 문)
```

### 5.1.1 문의 완료 값

```javascript
var a = 24;
var b = 13;
// undefeind
a = b;
// 13
```

a = b 는 할당 이후의 완료 값이지만, var 문 자체의 완료 값은 undefined다. (명세에 그렇게 적혀있기 때문이다.)



```javascript
var a, b;
// undefined

if (true) {
  b = 4 + 38;
}
// 42

/*
a = if (true) {
  b = 4 + 38;
}
*/
```

블록의 완료 값은 내부에 있는 마지막 문의 값을 암시적으로 반환한 값이다. 문의 완료 값을 포착하여 다른 변수에 할당하는 것은 불가능하다.

```javascript
// ES7에서는 가능한 do 표현 (블록 실행 후 블록 내 마지막 완료 값을 반환한다.)
var a, b;

a = do {
  if (true) {
    b = 4 + 38;
  }
}

a;
// 42
```

완료값을 포착하려면 어쩔 수 없이 eval을 사용할 수밖에 없다. (하지만 권장하지 않는다.)

```javascript
var a, b;
a = eval("if (true) { b = 4 + 38; }");
a; //42
```

### 5.1.2 표현식의 부수 효과

```javascript
function foo() {
  a = a + 1;
}
var a = 1;
foo(); // 결괏값: 'undefined', 부수 효과: 'a'가 변경됨
```

함수 호출 **표현식**은 부수 효과를 가진 표현식의 전형적인 예이다.

```javascript
var a = 42;
a++; // 42
a; //43

a--; // 43
a; // 42

++a // 43
var b = (a++); 
b; // 43
a; // 44

b = (a++, a);
b // 45
```

증감 연산자는 값을 반환하기 이전 또는 반환한 이후에 부수 효과가 발생한다.

```javascript
var obj = {
  a: 42
};
obj.a; // 42
delete obj.a; // true
obj.a; // undefined
```

delete 연산자 역시 부수 효과를 일으키는 연산자이다. 

```javascript
var a ;

a = 42; // 42
a; // 42
```

a = 42에서 = 연산자는 부수 효과와는 무관해 보이지만 a = 42 문의 실행 결과는 이제 막 할당된 값(42) 이므로 42를 a에 할당하는 자체가 본질적으로 부수 효과이다.

##### 중괄호

자바스크립트에서 { } 가 나올법 한 곳은 아래와 같다,

- 객체 리터럴

- 레이블 (goto문과 같은 동작, 쓰지 않는것을 권장)

  - ```javascript
    function foo() {
        bar: {
            console.log("Hello");
            break bar; // (lable name)
        }
        
        console.log("world");
    }
    ```

- 블록

  - ```javascript
    [] + {}; // "[object Object]"
    {} + []; // 0 : {}를 빈 블록으로 인식
    ```

- 객체분해

  - ```javascript
    <Component name={'John'} age={20} />
      
    function Component({name, age}) {// props 
    //...
    }
    ```

- else if (실제로는 else if는 없으며 if, else 로 구성됨)

  - ```javascript
    if(a) {
       
    } else {
      if() {
         
      } ...
    }
    ```

    
