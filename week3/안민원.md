---
tags: You Dont Know JS
---

# Week 3

### 4.4 암시적 변환

- 부수 효과가 명확하지 않게 숨겨진 형태로 일어나는 타입 변환
- 암시적 강제변환의 목적은 불필요한 상세 구현을 줄이는 것

#### 4.4.1 암시적이란?

- 예를 들어 a 타입을 b 타입으로 변경하기 위해서 중간 단계로 c를 거치는 경우가 있다.
- TypeB(TypeC(a)) -> TypeB(a) 이렇게 코드를 쓸 수 있다면 타입변환을 단순화 했다고 할 수 있다.
- 저자는 실제로 이것이 코드 가독성을 높이고 세세한 구현부를 추상화하거나 감추는 데 도움이 된다고 생각한다.
- 암시적 강제변환은 우리가 작성하는 코딩에 도움을 줄 수 있다.

#### 4.4.2 암시적 강제변환: 문자열 <-> 숫자

- - 연산자는 '숫자의 연산', '문자열 접합' 두가지 기능이 있다.

```javascript
var a = "42";
var b = "0";

var c = 42;
var d = 0;

a + b = "420";
c + d = 42;

var e = [1, 2];
var f = [3, 4];

e + f = "1,23,4";
```

- 한 쪽 피연산자가 문자열이거나 문자열 표현형으로 나타낼 수 있으면 문자열 붙이기를 한다. 그 밖에는 언제나 숫자 덧셈을 한다.
- 숫자는 공백 문자열 "" 와 더하면 간단히 문자열로 강제변환된다.
- String() 과의 차이점이 있는데 String()은 toString() 함수를 호출하는 것이고, 공백 문자열 연산은 ToPrimitive 과정에서 값을 valueOf() 메서드에 전달하여 호출하고 그 결괏값이 ToString() 연산을 하여 최종적인 문자열로 변환된다. 객체의 경우 문제가 될 수가 있지만 굳이 일부러 이런 객체를 만들지 않는 이상 크게 문제될 일은 없다.
- 연산 - 0과 \* 1, / 1 연산자는 문자열 -> 숫자로 강제변환을 한다.

#### 4.4.3 암시적 강제변환: 불리언 -> 숫자

- 범용적인 기법은 아니지만 특정 상황에선 기발한 해법이 될 수 있다.
- 숫자 + false or true에서 불리언은 숫자로 암시적인 강제변환이 된다.
- 여기서 논의한 모든 것들에 대한 판단은 우리 몫이다.

#### 4.4.4 암시적 강제변환: \* -> 불리언

- 불리언으로의 강제변환이 일어나는 표현식들

1. if () 문의 조건 표현식
2. for ( ; ; )에서 두 번째 조건 표현식
3. while () 및 do...while () 루프의 조건 표현식
4. ? : 삼항 연산 시 첫 번째 조건 표현식
5. || 및 &&의 좌측 피연산자

- 이런 콘텍스트에서 불리언 아닌 값이 사용되면 불리언 값으로 암시적 강제변환된다.

```javascript
var a = 42;
var b = "abc";
var c;
var d = null;

if (a) {
  console.log("hi"); // hi
}

while (c) {
  console.log("실행 절대 안됨");
}

c = d ? a : b; // "abc"

if ((a && d) || c) {
  console.log("hi"); // hi
}
```

#### 4.4.5 &&와 || 연산자

- 자바스크립트에서 이 두 연산자는 다른 언어와 달리 실제로 결괏값이 논리 값이 아니다.
- 결괏값은 두 피연산자 중 한쪽 값이다.

```javascript
var a = 42;
var b = "abc";
var c = null;

a || b; // 42
a && b; // "abc"

c || b; // "abc"
c && b; // null
```

- 연산자는 첫 번째 피연산자의 불리언 값을 평가한다. 피연산자가 비 불리언 타입이면 먼저 ToBoolean으로 강제변환 후 평가를 계속한다.
- || 연산자는 그 결과가 true면 첫 번째 피연산자 값을, false면 두 번째 피연산자 값을 반환한다
- && 연산자는 true면 두 번째 피연산자의 값을, false면 첫 번째 피연산자의 값을 반환한다.

#### 4.4.6 심벌의 강제변환

- 심벌 -> 문자열의 암시적 강제변환은 금지되고 에러가 난다.
- 불리언 값으로는 명시적/암시적 모드 강제변환이 가능하다. (truthy 값)

### 4.5 느슨한/엄격한 동등 비교

- 느슨한 동등 비교는 == 연산자를, 엄격한 동등 비교는 === 연산자를 사용함
- 동등함의 비교시 ==는 강제변환을 허용하지만, ===는 강제변환을 허용하지 않는다.

#### 4.5.1 비교 성능

- ==는 타입이 다를 경우 강제변환을 해야 하므로 ==가 더 할 일이 많다. 몇 마이크로초 정도 차이가 난다. (백만 분의 1초)
- 타입이 같은 두 값의 동등 비교라면, ==와 ===의 알고리즘은 동일하다.

#### 4.5.2 추상 동등 비교

- ES5 11.9.3에 추상적 동등 비교 알고리즘에 강제변환을 어떻게 수행하는지 그 방법이 적혀있다.
- 객체의 동등 비교에서 ==과 ===는 동일한 로직을 사용한다. 두 객체가 정확히 똑같은 값에 대한 레퍼런스일 경우에만 동등하다.

##### 문자열 -> 숫자

- 하나가 문자열, 하나가 숫자라면 문자열을 숫자로 비교해서 변환한다.

##### \* -> 불리언

- 가장 끔찍한 강제변환 함정이 자주 일어나는 곳이다.
- 숫자 vs 불리언인 경우 불리언을 숫자로 바꿔서 비교한다.
- 문자 vs 불리언인 경우,

1. 불리언을 숫자로 먼저 강제 변환
2. 문자열을 숫자로 강제 변환하여 그 둘을 비교한다.

##### 비교하기: null -> undefined

- null과 undefined를 느슨한 동등 비교하면 서로에게 타입을 맞춘다. 결과적으로 true가 나온다.

##### 비교하기: 객체 -> 비객체

- 먼저 객체에 대해 ToPrimitive() 한 결과를 가지고 비교를 한다.

```javascript
var a = 42;
var b = [42];

a == b; // true
```

- 위 예에서 b가 먼저 문자열 "42"로 바뀌고, 그 둘을 서로 비교한다.
- null과 undefined는 객체 래퍼가 따로 없으므로 박싱할 수 없다.

#### 4.5.3 희귀 사례

- 말 그대로 희귀사례. 괜히 내장 함수를 자기 멋대로 바꿔서는 결과가 이상하다고 한탄하지 말자.
- 책에서 괜히 억지 코드를 만들어서 설명해주는데, 저자도 직접 다 써놓고 "이런 코드는 그 자체로 공해니 생각조차 말고 강제변환을 비난하는 근거로 제시하지도 말자" 라고 설명한다. 말도 안되는 장난은 피하면 그만이라고 한다.
- 책 p141에 나와있는 나쁜 부분 7인방이라고 저자가 예측하기 어려운 느슨한 동등 비교 7개를 모아놨는데, 본인이 이런 의미 없는 비교는 절대 하지 말자고 써놨다. 애초에 엄격한 동등 비교만 하면 실무에서 이런 일을 겪을 필요가 없다.

##### 암시적 강제변환의 안전한 사용법

- 피연산자중 하나가 true/false일 가능성이 있으면 '절대로' == 연산자를 쓰지 말자.
- 피연산자 중 하나가 [], "", 0이 될 가능성이 있으면 가급적 == 연산자를 쓰지 말자.
- 결론은 엄격한 동등 비교를 사용하면 될 일이다.

### 4.6 추상 관계 비교

- 비교 시 피연산자 모두 문자열일 때와 그 외의 경우, 두 가지로 나뉜다.

1. 먼저 두 피연산자에 대해 ToPrimitive() 강제변환을 실시한다.
2. 어느 한쪽이라도 문자열이 아닐 경우 양쪽 모두 ToNumber로 강제변환하여 숫자값으로 비교를 한다.

- 비교 대상이 모두 문자열 값이면, 각 문자를 단순 어휘 비교한다.

```javascript
var a = [42];
var b = ["43"];

a < b; // true
b < a; // false

var a = ["42"];
var b = ["043"];

a < b; // false

var a = { b: 42 };
var b = { b: 43 };

a < b; // false
a <= b; // true
a >= b; // true
```

- a <= b는 실제로 b > a의 평가 결과를 부정하도록 명세에 기술되어 있다. 같거나 더 작은이라는 수학적인 의미가 아니라, 더 크지 않은 (!(a > b))의 의미로 해석한다.
- 조심해서 관계 비교를 해야할 것 같은 상황에서는 부등호를 사용하기 전에 비교할 값들을 명시적으로 강제변환 해두는 게 낫다.

## Ch5 문법

### 5.1 문과 표현식

#### 5.1.1 문의 완료 값

#### 5.1.2 표현식의 부수 효과

#### 5.1.3 콘텍스트 규칙
