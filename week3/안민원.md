---
tags: You Dont Know JS
---

# Week 3

### 4.4 암시적 변환

- 부수 효과가 명확하지 않게 숨겨진 형태로 일어나는 타입 변환
- 암시적 강제변환의 목적은 불필요한 상세 구현을 줄이는 것

#### 4.4.1 암시적이란?

- 예를 들어 a 타입을 b 타입으로 변경하기 위해서 중간 단계로 c를 거치는 경우가 있다.
- TypeB(TypeC(a)) -> TypeB(a) 이렇게 코드를 쓸 수 있다면 타입변환을 단순화 했다고 할 수 있다.
- 저자는 실제로 이것이 코드 가독성을 높이고 세세한 구현부를 추상화하거나 감추는 데 도움이 된다고 생각한다.
- 암시적 강제변환은 우리가 작성하는 코딩에 도움을 줄 수 있다.

#### 4.4.2 암시적 강제변환: 문자열 <-> 숫자

- - 연산자는 '숫자의 연산', '문자열 접합' 두가지 기능이 있다.

```javascript
var a = "42";
var b = "0";

var c = 42;
var d = 0;

a + b = "420";
c + d = 42;

var e = [1, 2];
var f = [3, 4];

e + f = "1,23,4";
```

- 한 쪽 피연산자가 문자열이거나 문자열 표현형으로 나타낼 수 있으면 문자열 붙이기를 한다. 그 밖에는 언제나 숫자 덧셈을 한다.
- 숫자는 공백 문자열 "" 와 더하면 간단히 문자열로 강제변환된다.
- String() 과의 차이점이 있는데 String()은 toString() 함수를 호출하는 것이고, 공백 문자열 연산은 ToPrimitive 과정에서 값을 valueOf() 메서드에 전달하여 호출하고 그 결괏값이 ToString() 연산을 하여 최종적인 문자열로 변환된다. 객체의 경우 문제가 될 수가 있지만 굳이 일부러 이런 객체를 만들지 않는 이상 크게 문제될 일은 없다.
- 연산 - 0과 \* 1, / 1 연산자는 문자열 -> 숫자로 강제변환을 한다.

#### 4.4.3 암시적 강제변환: 불리언 -> 숫자

- 범용적인 기법은 아니지만 특정 상황에선 기발한 해법이 될 수 있다.
- 숫자 + false or true에서 불리언은 숫자로 암시적인 강제변환이 된다.
- 여기서 논의한 모든 것들에 대한 판단은 우리 몫이다.

#### 4.4.4 암시적 강제변환: \* -> 불리언

- 불리언으로의 강제변환이 일어나는 표현식들

1. if () 문의 조건 표현식
2. for ( ; ; )에서 두 번째 조건 표현식
3. while () 및 do...while () 루프의 조건 표현식
4. ? : 삼항 연산 시 첫 번째 조건 표현식
5. || 및 &&의 좌측 피연산자

- 이런 콘텍스트에서 불리언 아닌 값이 사용되면 불리언 값으로 암시적 강제변환된다.

```javascript
var a = 42;
var b = "abc";
var c;
var d = null;

if (a) {
  console.log("hi"); // hi
}

while (c) {
  console.log("실행 절대 안됨");
}

c = d ? a : b; // "abc"

if ((a && d) || c) {
  console.log("hi"); // hi
}
```

#### 4.4.5 &&와 || 연산자

- 자바스크립트에서 이 두 연산자는 다른 언어와 달리 실제로 결괏값이 논리 값이 아니다.
- 결괏값은 두 피연산자 중 한쪽 값이다.

```javascript
var a = 42;
var b = "abc";
var c = null;

a || b; // 42
a && b; // "abc"

c || b; // "abc"
c && b; // null
```

- 연산자는 첫 번째 피연산자의 불리언 값을 평가한다. 피연산자가 비 불리언 타입이면 먼저 ToBoolean으로 강제변환 후 평가를 계속한다.
- || 연산자는 그 결과가 true면 첫 번째 피연산자 값을, false면 두 번째 피연산자 값을 반환한다
- && 연산자는 true면 두 번째 피연산자의 값을, false면 첫 번째 피연산자의 값을 반환한다.

#### 4.4.6 심벌의 강제변환

- 심벌 -> 문자열의 암시적 강제변환은 금지되고 에러가 난다.
- 불리언 값으로는 명시적/암시적 모드 강제변환이 가능하다. (truthy 값)

### 4.5 느슨한/엄격한 동등 비교

- 느슨한 동등 비교는 == 연산자를, 엄격한 동등 비교는 === 연산자를 사용함
- 동등함의 비교시 ==는 강제변환을 허용하지만, ===는 강제변환을 허용하지 않는다.

#### 4.5.1 비교 성능

- ==는 타입이 다를 경우 강제변환을 해야 하므로 ==가 더 할 일이 많다. 몇 마이크로초 정도 차이가 난다. (백만 분의 1초)
- 타입이 같은 두 값의 동등 비교라면, ==와 ===의 알고리즘은 동일하다.

#### 4.5.2 추상 동등 비교

- ES5 11.9.3에 추상적 동등 비교 알고리즘에 강제변환을 어떻게 수행하는지 그 방법이 적혀있다.
- 객체의 동등 비교에서 ==과 ===는 동일한 로직을 사용한다. 두 객체가 정확히 똑같은 값에 대한 레퍼런스일 경우에만 동등하다.

##### 문자열 -> 숫자

- 하나가 문자열, 하나가 숫자라면 문자열을 숫자로 비교해서 변환한다.

##### \* -> 불리언

- 가장 끔찍한 강제변환 함정이 자주 일어나는 곳이다.
- 숫자 vs 불리언인 경우 불리언을 숫자로 바꿔서 비교한다.
- 문자 vs 불리언인 경우,

1. 불리언을 숫자로 먼저 강제 변환
2. 문자열을 숫자로 강제 변환하여 그 둘을 비교한다.

##### 비교하기: null -> undefined

- null과 undefined를 느슨한 동등 비교하면 서로에게 타입을 맞춘다. 결과적으로 true가 나온다.

##### 비교하기: 객체 -> 비객체

- 먼저 객체에 대해 ToPrimitive() 한 결과를 가지고 비교를 한다.

```javascript
var a = 42;
var b = [42];

a == b; // true
```

- 위 예에서 b가 먼저 문자열 "42"로 바뀌고, 그 둘을 서로 비교한다.
- null과 undefined는 객체 래퍼가 따로 없으므로 박싱할 수 없다.

#### 4.5.3 희귀 사례

- 말 그대로 희귀사례. 괜히 내장 함수를 자기 멋대로 바꿔서는 결과가 이상하다고 한탄하지 말자.
- 책에서 괜히 억지 코드를 만들어서 설명해주는데, 저자도 직접 다 써놓고 "이런 코드는 그 자체로 공해니 생각조차 말고 강제변환을 비난하는 근거로 제시하지도 말자" 라고 설명한다. 말도 안되는 장난은 피하면 그만이라고 한다.
- 책 p141에 나와있는 나쁜 부분 7인방이라고 저자가 예측하기 어려운 느슨한 동등 비교 7개를 모아놨는데, 본인이 이런 의미 없는 비교는 절대 하지 말자고 써놨다. 애초에 엄격한 동등 비교만 하면 실무에서 이런 일을 겪을 필요가 없다.

##### 암시적 강제변환의 안전한 사용법

- 피연산자중 하나가 true/false일 가능성이 있으면 '절대로' == 연산자를 쓰지 말자.
- 피연산자 중 하나가 [], "", 0이 될 가능성이 있으면 가급적 == 연산자를 쓰지 말자.
- 결론은 엄격한 동등 비교를 사용하면 될 일이다.

### 4.6 추상 관계 비교

- 비교 시 피연산자 모두 문자열일 때와 그 외의 경우, 두 가지로 나뉜다.

1. 먼저 두 피연산자에 대해 ToPrimitive() 강제변환을 실시한다.
2. 어느 한쪽이라도 문자열이 아닐 경우 양쪽 모두 ToNumber로 강제변환하여 숫자값으로 비교를 한다.

- 비교 대상이 모두 문자열 값이면, 각 문자를 단순 어휘 비교한다.

```javascript
var a = [42];
var b = ["43"];

a < b; // true
b < a; // false

var a = ["42"];
var b = ["043"];

a < b; // false

var a = { b: 42 };
var b = { b: 43 };

a < b; // false
a <= b; // true
a >= b; // true
```

- a <= b는 실제로 b > a의 평가 결과를 부정하도록 명세에 기술되어 있다. 같거나 더 작은이라는 수학적인 의미가 아니라, 더 크지 않은 (!(a > b))의 의미로 해석한다.
- 조심해서 관계 비교를 해야할 것 같은 상황에서는 부등호를 사용하기 전에 비교할 값들을 명시적으로 강제변환 해두는 게 낫다.

## Ch5. 문법

### 5.1 문과 표현식

- 문장은 생각을 표현하는 단어들의 완전한 조형물이다. 어구는 구두점이나 접속사로 연결할 수 있고 어구는 더 작ㅇ느 어구로 나눌 수 있다. 어떤 어구는 불완전하여 그 자체로 완성된 문장을 형성할 수 없지만 스스로의 힘만으로 완성되는 어구도 있다.
- 자바스크립트에서는 문은 문장, 표현식은 어구, 연산자는 구두점/접속사에 해당된다. 자바스크립트에서 모든 표현식은 단일한, 특정한 결괏값으로 계산된다.

```javascript
var a = 3 * 6
var b = a;
b;
```

- 위 예에서 3*6은 표현식이다. 나머지도 모두 표현식이다. 
- 위 세 줄은 각각 표현식이 포함된 문이다. 세 번째 줄은 표현식의 전부지만 이것만으로도 완전한 문이다. 이런 것을 '표현식 문'이라고 한다.

#### 5.1.1 문의 완료 값

- 모든 문은 완료 값을 가진다.
- 콘솔 창은 가장 최근에 실행된 문의 완료 값을 기본적으로 출력하게 되어 있다.
- 위 예에서 할당 표현식 b = a는 할당 이후의 값이 완료 값이지만, var 문 자체의 오나료 값은 undefined이다.
- 콘솔 창이 내어준 완료 값은 개발자가 내부 프로그램에서 사용할 수 있는 값은 아니다. 
- 완료 값을 내부 프로그램에서 사용하기 위해서는 ES7 명세에서 사용할 수 있는 do 표현식을 사용하면 된다.

```javascript
var a, b;
a = do {
    if (true) {
        b = 4 + 38;
    }
}

a // 42
```

do {} 표현식은 블록 실행 후 블록 내 마지막 문의 완료 값을 do 표현식 전체의 완료 값으로 반환하며 결국 이 값이 변수 a에 할당된다.

#### 5.1.2 표현식의 부수 효과

- 부수 효과가 있는 표현식들이 있다.

```javascript
function foo() {
    a = a + 1;
};

var a = 1;
foo()// 결괏값은 undefined, 부수 효과는 a에 1이 더해짐
```

```javascript
var a = 42;
var b = a++;

a // 43
b // 42
```

- 위 예에서 표현식 a++가 하는 일은 두 가지다. a의 현재값 42를 반환하는 것, 그리고 a를 1만큼 증가시키는 것
- 단항 연산자인 증가 연산자 / 감소 연산자는 전위 또는 후위 연산자로 사용된다.

```javascript
var a = 42;

a++ // 42
a; // 43

++ a // 44
a; // 44
```

- 후위 연산자를 괄호로 감싸도 부수 효과 발생 이후 새 표현식을 만들어 내는 것은 불가능하다.
- 단 아래 예제처럼 문을 나열하는 콤마 연산자를 사용하면 다수의 개별 표현식을 하나로 연결할 수 있다.

```javascript
var a = 42, b;
b = (a++, a)

a // 43
b // 43
```

- a++, a 표현식은 두 번째 a 표현식을 첫 번째 a++  표현식에서 부수 효과가 발생한 이후에 평가한다. 그래서 b 값은 43이다.
- delete 연산자의 결괏값은 유효한/허용된 연산일 경우 true, 그 외에는 false다. 이 연산자의 부수 효과는 프로퍼티를 제거하는 것이다.
- = 할당 연산자는 부수 효과와는 무관해 보이지만 a = 42의 실행 결과는 42이고, 본질ㅈ적으로 42를 a에 할당하는 자체가 부수효과이다. 이런 효과는 아래 예처럼 연쇄 할당문에서 특히 유용하다.
- var a = b = 42처럼 사용하는 것은 잘못된 사용이다. 변수 b를 선언하지 않은 상태에서 실행하면 이 할당문은 b를 직접 선언하지 않는다. 대신 엄격 모드 여부에 따라 에러가 나거나 원치 않은 전역 변수가 생성된다.

```javascript
var a, b, c;
a = b = c = 42;
```

#### 5.1.3 콘텍스트 규칙

- 자바스크립트 문법 규칙 중에는 같은 구문이지만 어디에서 어떤 식으로 사용하느냐에 따라 서로 다른 의미를 가지는 경우가 있다. 그 중 몇가지만 살펴 본다.
- 