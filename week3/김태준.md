
###4.3 명시적 강제변환

####4.3.1. 명시적 강제변환 : 문자열 <-> 숫자

- 문자열 <-> 숫자 강제변환은 **String( )과 Number( ) 함수**를 이용하는데, 앞에 new 키워드가 붙지 않으므로 객체 레퍼를 생성하는 것이 아님

```
  var a = 42;
  var b = String(a);  // typeof String
  var s = new String(a); // typeof Object

  var c = "3.14";
  var d = Number(c);

  b; // "42"
  c; // 3.14
  s; // String { "42" }
  s.toString( ); // "42"

```

- String( )과 Number( ) 이외의 '문자열 <-> 숫자'의 명시적인 타입변환 방법
- a라는 원시 타입은 toString( ) 메서드가 없으므로 js 엔진은 toString( )을 사용할 수 있게 자동으로 42 -> String{"42"}로 박싱한다.

```
   var a = 42;
   var b = a.toString( );

   var c - "3.14";
   var d = +c;

   b; // "42"
   d; // 3.14   

```

- 날짜 <-> 숫자
--  + 단항 연산자는 Date 객체 -> 숫자 강제변환 용도로 쓰인다.

```
   var d = new Date("Mon, 18 Aug 2014 08:53:06 CDT");
   +d; // 1408369986000
```
- 위 방법보다는 강제변환을 하지 않고 명시적으로 하는 방법이 추천된다.
```
   var timestamp = new Date(1992,04,07).getTime(); // 특정 날짜/시간의 타임스탬프
   var timestamp = Date.now( ); // 현재 시간의 타임스탬프
```
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime

- 이상한 나라의 틸드(~)
-- ~ 연산자는 32비트 숫자로 강제(ToInt)변환 한 후 NOT 연산을 한다. ( 각 비트를 거꾸로 뒤집는다. ) -  ~x는 대략 -(x+1)

```
   -42; // -(42+1) ==> -43
```

- indexOf -> 찾으면 위치한 index, 못찾으면 -1
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf

```
   var a = "Hello World";
   
  //해당 값이 존재하는 경우

   if(a.indexOf("lo") >= 0 ) {  //3

    }
 
   if(a.indexOf("lo") != -1) {  // 3

   }

  //해당 값이 존재하지 않는 경우

  if(a.indexOf("ol") < 0 { // -1

   }

  if(a.indexOf("ol") == -1) {

  }
```

- ~(딜트)는 indexOf( )로 검색 결과 '실패'시 -1을 falsy한 0으로, 그 외에 truthy한 값으로 바꾼다.

```
   var a = "Hello World";

   ~a.indexOf("lo"); // -4
   if(~a.indexOf("lo")) {
        // 찾았다.
    }

    ~a.indexOf("ol"); // 0
    if(!~a.indexOf("ol")) {
        // 못 찾았다.
   }
```  
  
- 비트잘라내기
-- ~~를 통해 숫자의 소수점을 잘라낼 수 있다. Math.floor와 같다고 생각할 수 있지만 **값이 음수인 경우 다르다.** ( Math.floor의 경우 해당 숫자보다 작은 가장 큰 정수를 return하고 ~~는 그 숫자에서 소수점을 빼버린 숫자이다.)

```
   Math.floor(49.6); // 49 
   ~~49.6; // 49

   Math.floor(-49.6); // -50
   ~~-49.6; // -49

```

#### 4.3.2 명시적 강제변환: 숫자 형태의 문자열 파싱

- parseInt : 좌 -> 우 방향으로 파싱하다 숫자가 아닌 문자를 만나면 즉시 멈춘다.
- Number : 강제변환은 비 숫자형 문자를 허용하지 않기 때문에 바로 NaN을 리턴한다.

```
   var a = "42";
   var b = "42px";
   
   Number( a ); // 42
   parseInt( a ); // 42

   Number( b ); // NaN
   parseInt ( b ); // 42
```

-  **parseInt( )는 문자열에 쓰이는 함수이다.** 인자가 숫자라면 parseInt()를 쓸 이유가 없고, 다른 타입값들 역시 마찬가지이다.  **문자가 아닐 경우에 제일 먼저 자동으로 문자열로 강제변환을 시킨다.** ( 이부분에서 오류가 발생할 수 있음. 따라서, 바람직하지 않음.) -> 결론은 parseInt에 문자열만 넣어라.

- parseInt 비 문자열 파싱

```
   parseInt( new String("42"));  // "42" -> 42
   var a = {
       num: 21,
       toString: function( ) { return String( this.num * 2); }
   };

  parseInt( a ); //  a.toString( ) -> String { "42"}  -> "42" -> 42
```

#### 4.3.3 명시적 강제변환: * -> 불리언
- 다음은 비 불리언 -> 불리언 강제변환이다.
- String( ), Number( )도 그렇듯이 Boolean( )은 명시적인 강제변환 방법이다.

```
 var a = "0";
 var b = [ ];
 var c = { };

 var d = "";
 var e = 0;
 var f = null;
 var g;

 Boolean( a ); // true  -> !!a
 Boolean( b ); // true  -> !!b
 Boolean( c ); // true   -> !!c
 
 Boolean( d ); // false  -> !!d
 Boolean ( e ); // false  -> !!e  
 Boolean ( f ); // false   -> !!f
 Boolean ( g ); // false  -> !!g
```

- Boolean( )이나 !!를 쓰지 않으면 암시적 강제변환이 일어난다. ( 비추천 )
```
   var a = 42;
   var b = a ? true : false; // a의 암시적 강제변환이 발생한다.
```

### 4.4 암시적 변환
- 숨겨진 형태로 일어나는 타입변환이다.
- 명시적 강제변환(개발자가 의도함)의 목적은 분명하고 암시적 강제변환(개발자가 의도하지 않을 수 있음)의 목적은 그 반대이다.

#### 4.4.1 '암시적'이란?
- 필자의 생각 : 아래 코드 처럼 명시적으로 y -> Another -> SomeType으로 변환하게 되면 코드가 장황해지고 이런 과정을 사람들이 다 이해할 필요 없다고 생각. 반면, 암시적은  y -> someType이므로 중간단계를 줄여 타입변환을 단순화하고 코드의 가독성을 높인다.
```
   SomType x  = SomeType( AnotherType( y )); -> 명시적

   SomType x = SomeType ( y ) -> 암시적
```

#### 4.2.2 암시적 강제변환 : 문자열 <-> 숫자

```
  var a = 42;
  var b = a + "";
   
  b; // "42"
```

- 명시적 강제변환 String( a )과 암시적 강제변환 a + ""를 사용하면서 주의해야 할 점이 있다.  먼저, ToPrimitive 연산 과정에서 a + "" a값을 valueOf( ) 메서드에 전달하여 호출하고, 그 결과값을 ToString으로 문자열로 리턴한다. 그러나, String( a )는 단순히 toString( )을 호출할 뿐이다.
따라서, 다음 a 객체에 대해서는 명시적방법과 암시적 방법의 값이 다를 수 있다. -> **valueOf( ), toString( ) 메서드를 오버라이드 한 객체의 강제변환 과정에서는 결과 값이 달라질 수 있기 때문에 주의한다.**

```
  var a = {
      valueOf: functon( ) { return 42; }
      toString: function( ) { return 4; }
   };

   a + ""; // "42"  // valueOf 호출 
   String ( a ); // "4" // toString 호출
```

#### 4.4.3 암시적 강제변환: 불리언 -> 숫자
- 암시적 강제변환의 효용성은 복잡한 형태의 불리언 로직을 단순한 숫자 덧셈 형태로 단순화 할 때 빛을 바란다.

- onlyOne( )는 세 인자 중 정확히 하나만 true일 때 true를 return.  인자 갯ㅅ가 많아 질 경우 비교하는 로직이 복잡해짐.
```
   function onlyOne(a, b, c) {
     return (a && !b && !c) || (!a && b && !c) || (!a && !b && c));
   }
```

- 위 코드의 복잡성을 불리언 값을 숫자로 변화하면 문제가 쉽게 해결된다.
```
   function onlyOne( ) {
      var sum = 0;
      for(var i=0; i < arguments.length; i++) {
          if(arguments[i]) {
                sum += arguments[i]; // 암시적 형변환 ( boolean -> int )
               // sum += Number ( arguments[i] ); // 명시적 형변환
          }
     }
     return sum == 1;
  }
 ```


#### 4.4.4 암시적 강제변환 : * -> 불리언
- 다음은 불리언으로의 강제변환이 일어는 표현식이다.
   1. if ( ) 문의 조건 표현식
   2. for(  ;   ;   ) 에서 두 번째 조건 표현식
   3. while( ) 및 do...while( ) 루프의 조건 표현식
   4. ? : 삼항 연산 시 첫 번째 조건 표현식
   5. || (논리 OR) 및 &&(논리 AND)의 좌측 피연산자

- 이런 콘텍스트에서 불리언이 아닌 값이 사용되면, 이 장 앞부분에서 언급했던 ToBoolean 추상 연산 규칙에 따라 일단 불리언 값으로 암시적 강제변환된다.

```
  var a = 42;
  var b = "abc";
  var c;
  var d = null;

   if(a) { 
       console.log("넵"); // 넵
   }
   
   while ( c ) {
       console.log(" no ! ");
   }

   c = d ? a : b
   c; // "abc"

  if((a && d) || c ) {
      console.log("넵");  // 넵
  }
```
